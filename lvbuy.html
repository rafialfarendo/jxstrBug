<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>LIVECHAT JXSTR - JxstrBan V1</title>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #030303;
            --red-1: #ff4b4b;
            --red-2: #ff6b6b;
            --red-3: #ff8b8b;
            --radius: 22px;
            --font-stack: "Orbitron", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; user-select: none; }
        html, body { height:100%; background:#000; font-family:var(--font-stack); color:#fff; overflow:hidden; touch-action:manipulation; }
        .app { width:100%; height:100vh; position:relative; display:flex; flex-direction:column; }
        .topbar { height:64px; display:flex; align-items:center; justify-content:space-between; padding:0 20px; background:linear-gradient(180deg,#000 0%,#050405 100%); border-bottom:1px solid rgba(255,60,60,0.2); }
        .back-btn { width:40px; height:40px; border-radius:10px; display:flex; align-items:center; justify-content:center; color:var(--red-2); cursor:pointer; transition:transform .15s ease; }
        .title { flex:1; font-size:21px; letter-spacing:2px; color:var(--red-2); text-align:center; font-family:var(--font-stack); }
        .header-pill { margin:10px 20px; padding:12px; border-radius:18px; background:linear-gradient(180deg,rgba(255,75,75,0.06),rgba(255,75,75,0.02)); border:2px solid rgba(255,60,60,0.24); text-align:center; font-size:16px; color:var(--red-1); box-shadow:0 6px 30px rgba(255,60,60,0.06); letter-spacing:1px; font-family:var(--font-stack); }
        .chat-messages { flex:1; padding:20px; overflow-y:auto; background:#000; }
        .message { margin-bottom:15px; padding:12px 16px; border-radius:18px; max-width:80%; word-wrap:break-word; backdrop-filter: blur(6px); border:1px solid rgba(255,255,255,0.03); animation:fadeIn .3s ease; font-family:var(--font-stack); }
        .user-message { background:linear-gradient(180deg, rgba(255,75,75,0.12), rgba(255,40,40,0.03)); border:1px solid rgba(255,70,70,0.16); color:var(--red-1); margin-left:auto; border-bottom-right-radius:5px; }
        .bot-message { background:linear-gradient(180deg, rgba(255,60,60,0.10), rgba(255,90,90,0.02)); border:1px solid rgba(255,80,80,0.14); color:var(--red-2); border-bottom-left-radius:5px; }
        .system-message { background:linear-gradient(180deg, rgba(255,90,90,0.10), rgba(255,120,120,0.02)); border:1px solid rgba(255,100,100,0.14); color:var(--red-3); text-align:center; max-width:90%; margin:10px auto; font-size:12px; }
        .message-time { font-size:0.7em; opacity:0.7; margin-top:5px; text-align:right; color:rgba(255,255,255,0.6); }
        .chat-input-container { padding:12px 16px; background:rgba(10,0,0,0.8); border-top:1px solid rgba(255,60,60,0.2); display:flex; gap:8px; align-items:center; }
        .chat-input { flex:1; padding:12px 18px; background:rgba(255,60,60,0.08); border:1px solid rgba(255,60,60,0.3); border-radius:12px; color:white; font-family:var(--font-stack); font-size:14px; outline:none; }
        .chat-input:focus { border-color:var(--red-2); box-shadow:0 0 10px rgba(255,75,75,0.3); }
        .icon-btn { width:44px; height:44px; border-radius:12px; display:flex; align-items:center; justify-content:center; background:rgba(255,60,60,0.12); border:1px solid rgba(255,60,60,0.22); color:var(--red-2); cursor:pointer; transition:all .2s ease; font-size:22px; font-weight:700; line-height:1; }
        .icon-btn:hover { transform:translateY(-2px); }
        .send-btn { width:45px; height:45px; background:var(--red-2); border:none; border-radius:12px; color:white; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:all .3s ease; box-shadow:0 4px 15px rgba(255,75,75,0.3); }
        .send-btn:hover { background:var(--red-1); transform:translateY(-2px); }
        .send-btn:active { transform:scale(0.95); }
        .typing-indicator { padding:10px 16px; color:var(--red-3); font-style:italic; display:none; text-align:center; font-size:12px; }
        .status-indicator { text-align:center; padding:10px; font-size:11px; color:var(--red-3); background:rgba(255,60,60,0.05); border-radius:8px; margin:0 20px 10px; }
        .session-info { text-align:center; padding:8px; font-size:10px; color:var(--red-3); background:rgba(255,60,60,0.08); border-radius:6px; margin:0 20px; border:1px solid rgba(255,60,60,0.2); }
        .message img.chat-image { max-width:320px; width:100%; height:auto; display:block; border-radius:12px; margin-bottom:8px; border:1px solid rgba(255,255,255,0.06); }
        @keyframes fadeIn { from { opacity:0; transform:translateY(10px); } to { opacity:1; transform:translateY(0); } }
        @keyframes clicky { 0%{transform:scale(1)}50%{transform:scale(0.92)}100%{transform:scale(1)} }
        .clicky { animation:clicky .25s ease; }
        .chat-messages::-webkit-scrollbar { width:6px; }
        .chat-messages::-webkit-scrollbar-track { background:rgba(255,60,60,0.1); border-radius:3px; }
        .chat-messages::-webkit-scrollbar-thumb { background:var(--red-2); border-radius:3px; }

        /* Modal */
        .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.75); display:flex; align-items:center; justify-content:center; z-index:9999; }
        .modal { width:92%; max-width:520px; background:linear-gradient(180deg,#0b0b0b,#0f0f0f); border-radius:14px; padding:20px; border:1px solid rgba(255,60,60,0.18); box-shadow:0 10px 50px rgba(0,0,0,0.6); color:#fff; font-family:var(--font-stack); }
        .modal h3 { margin-bottom:10px; color:var(--red-2); font-size:18px; letter-spacing:1px; text-align:center; }
        .modal p { font-size:13px; color:rgba(255,255,255,0.9); line-height:1.4; margin-bottom:18px; text-align:center; }
        .modal .modal-actions { display:block; }
        .btn { padding:12px 16px; border-radius:10px; cursor:pointer; border:none; font-weight:700; font-size:14px; width:100%; box-sizing:border-box; }
        .btn-close { background:linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02)); color:var(--red-1); border:1px solid rgba(255,60,60,0.12); }
        .modal .btn-close { font-family: var(--font-stack); }
        .btn-close:focus { outline:2px solid rgba(255,75,75,0.25); outline-offset:2px; }

        /* Blacklist modal (forced, cannot close) */
        .blacklist-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center; z-index:10000; }
        .blacklist-modal { width:92%; max-width:420px; background:linear-gradient(180deg,#0a0a0a,#0d0d0d); border-radius:16px; padding:28px 20px; text-align:center; border:1px solid rgba(255,40,40,0.16); box-shadow:0 18px 70px rgba(0,0,0,0.7); color:#fff; }
        .blacklist-modal .x-icon { width:68px; height:68px; border-radius:50%; margin:0 auto 16px; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(255,60,60,0.1), rgba(255,40,40,0.03)); border:1px solid rgba(255,60,60,0.12); color:var(--red-2); font-weight:800; font-size:28px; }
        .blacklist-modal h2 { color:var(--red-2); margin-bottom:8px; font-size:20px; }
        .blacklist-modal p { color:rgba(255,255,255,0.9); font-size:14px; line-height:1.4; }
        /* make sure no pointer cursor on backdrop to avoid hint of close */
        .blacklist-backdrop, .blacklist-modal { cursor:default; }
    </style>
</head>
<body>
    <div class="app">
        <div class="topbar">
            <div class="back-btn" onclick="goBack()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                     stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 12H5M12 19l-7-7 7-7"/>
                </svg>
            </div>
            <div class="title">LIVECHAT JXSR</div>
            <div style="width: 40px;"></div>
        </div>

        <div class="header-pill">LiveChat For Buy Only</div>

        <div class="session-info" id="sessionInfo">Session ID: Loading...</div>
        <div class="status-indicator" id="statusIndicator">Menghubungkan ke Server ...</div>

        <div class="chat-messages" id="chatMessages"><!-- Pesan akan dimuat dari localStorage --></div>

        <div class="typing-indicator" id="typingIndicator">sedang mengirim pesan...</div>

        <div class="chat-input-container" id="chatInputContainer">
            <button class="icon-btn" id="attachBtn" title="Kirim gambar" onclick="triggerImagePicker()">+</button>
            <input type="text" class="chat-input" id="messageInput" placeholder="Ketik pesan Anda..." maxlength="1000" onkeypress="handleKeyPress(event)">
            <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
            </button>
        </div>
    </div>

    <input type="file" id="imagePicker" accept="image/*" style="display:none" onchange="handleImageSelect(event)">
    <audio id="messageSound" preload="auto"><source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==" type="audio/wav"></audio>

    <script>
        // CONFIG
        const BOT_TOKEN = '8006024813:AAEI-y4VBZNLDwCqNIwF3GTNJRXS7HxHL5Y';
        const ADMIN_CHAT_ID = '8140169698';

        // LS keys
        const LS_LAST_UPDATE = 'jx_last_update';
        const LS_SESSION = 'jx_session';
        const LS_HISTORY_PREFIX = 'jx_history_';
        const LS_BLACKLIST = 'jx_blacklist_sessions'; // store array of blacklisted session ids

        // Globals
        let currentSessionId = null;
        let lastUpdateId = parseInt(localStorage.getItem(LS_LAST_UPDATE) || '0', 10) || 0;
        let chatHistory = [];
        let isFirstMessage = true;
        let welcomeMessageSent = false;
        let lastRequestTime = 0;
        const REQUEST_DELAY = 1000;
        let blacklistedSessions = loadBlacklistFromStorage(); // Set awal
        let isCurrentBlacklisted = false;

        // NEW: public IP info cache
        let publicIpInfo = null;

        // persistence helpers
        function saveLastUpdateId(id) {
            if (id === undefined || id === null) return;
            lastUpdateId = parseInt(id, 10) || lastUpdateId;
            try { localStorage.setItem(LS_LAST_UPDATE, String(lastUpdateId)); } catch (e) {}
        }

        function loadBlacklistFromStorage() {
            try {
                const raw = localStorage.getItem(LS_BLACKLIST);
                if (!raw) return {};
                const arr = JSON.parse(raw);
                // convert to object set for O(1) lookup
                const set = {};
                if (Array.isArray(arr)) arr.forEach(v => set[String(v)] = true);
                return set;
            } catch (e) { return {}; }
        }
        function saveBlacklistToStorage() {
            try {
                const arr = Object.keys(blacklistedSessions);
                localStorage.setItem(LS_BLACKLIST, JSON.stringify(arr));
            } catch (e) {}
        }
        function markSessionBlacklisted(sessionId) {
            blacklistedSessions[String(sessionId)] = true;
            saveBlacklistToStorage();
            if (String(sessionId) === String(currentSessionId)) {
                applyBlacklistedState(true);
            }
        }
        function unmarkSessionBlacklisted(sessionId) {
            delete blacklistedSessions[String(sessionId)];
            saveBlacklistToStorage();
            if (String(sessionId) === String(currentSessionId)) {
                applyBlacklistedState(false);
            }
        }

        // Session & history
        function loadSessionId() {
            const savedSession = localStorage.getItem(LS_SESSION);
            if (savedSession) {
                return parseInt(savedSession);
            } else {
                const newSessionId = Math.floor(Math.random() * 9999) + 1;
                localStorage.setItem(LS_SESSION, newSessionId.toString());
                return newSessionId;
            }
        }

        function loadChatHistory() {
            if (!currentSessionId) return;
            const savedHistory = localStorage.getItem(`${LS_HISTORY_PREFIX}${currentSessionId}`);
            if (savedHistory) {
                try {
                    chatHistory = JSON.parse(savedHistory);
                    const messagesContainer = document.getElementById('chatMessages');
                    messagesContainer.innerHTML = '';
                    chatHistory.forEach(msg => renderChatItem(msg));
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                } catch (error) {
                    console.error('Error loading chat history:', error);
                    chatHistory = [];
                }
            }
        }

        function renderChatItem(msg) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${msg.sender}-message`;
            if (msg.type === 'image' && msg.url) {
                messageDiv.innerHTML = `
                    <img src="${msg.url}" class="chat-image" alt="image message" />
                    ${msg.caption ? `<div style="margin-top:6px">${msg.caption}</div>` : ''}
                    <div class="message-time">${msg.displayTime || msg.time}</div>
                `;
            } else {
                messageDiv.innerHTML = `
                    ${msg.text || ''}
                    <div class="message-time">${msg.displayTime || msg.time}</div>
                `;
            }
            messagesContainer.appendChild(messageDiv);
        }

        function saveChatHistory() {
            if (!currentSessionId) return;
            try {
                localStorage.setItem(`${LS_HISTORY_PREFIX}${currentSessionId}`, JSON.stringify(chatHistory));
            } catch (error) { console.error('Error saving chat history:', error); }
        }

        // misc helpers
        function playMessageSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioContext.destination);
                oscillator.frequency.value = 800; oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + 0.1);
            } catch (error) {}
        }

        function getClientInfo() {
            return {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                screen: `${screen.width}x${screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                url: window.location.href
            };
        }

        // NEW: get public IP + location (tries multiple providers, fallback to Unknown)
        async function getPublicIpInfo() {
            if (publicIpInfo) return publicIpInfo;
            const endpoints = [
                'https://ipapi.co/json/',
                'https://ipinfo.io/json',
                'https://ip-api.com/json'
            ];
            for (const url of endpoints) {
                try {
                    const res = await fetch(url, { cache: 'no-store' });
                    if (!res.ok) continue;
                    const data = await res.json();
                    let info = { ip: '', city: '', region: '', country: '', org: '', lat: '', lon: '' };
                    if (data.ip) info.ip = data.ip;
                    if (data.city) info.city = data.city;
                    if (data.region) info.region = data.region || data.regionName;
                    if (data.country_name) info.country = data.country_name;
                    if (data.country && !info.country) info.country = data.country;
                    if (data.org) info.org = data.org;
                    if (data.loc) { const [lat, lon] = String(data.loc).split(','); info.lat = lat; info.lon = lon; }
                    if (data.latitude && data.longitude) { info.lat = data.latitude; info.lon = data.longitude; }
                    if (data.query && !info.ip) info.ip = data.query;
                    if (data.regionName && !info.region) info.region = data.regionName;
                    publicIpInfo = info;
                    return publicIpInfo;
                } catch (e) {
                    // try next
                }
            }
            publicIpInfo = { ip: 'Unknown', city: '', region: '', country: '', org: '', lat: '', lon: '' };
            return publicIpInfo;
        }

        async function fetchPendingUpdatesOnce() {
            try {
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getUpdates?offset=${lastUpdateId + 1}`);
                const data = await response.json();
                if (data.ok && data.result && data.result.length > 0) {
                    data.result.forEach(update => {
                        if (update.message && update.message.chat && String(update.message.chat.id) === String(ADMIN_CHAT_ID)) {
                            const replyText = update.message.text || '';
                            // process admin commands first (blacklist/unblacklist)
                            processAdminCommand(replyText);
                            // display admin replies as before (but not session-start broadcasts)
                            if (!replyText.includes('SESI CHAT BARU') &&
                                !replyText.includes('Session ID:') &&
                                !replyText.includes('Pesan dari Session')) {
                                const parsedReply = parseAdminReply(replyText);
                                if (parsedReply && parsedReply.sessionId === currentSessionId) {
                                    displayMessage(parsedReply.message, 'bot');
                                } else if (!parsedReply && replyText.length > 0) {
                                    displayMessage(replyText, 'bot');
                                }
                            }
                        }
                        saveLastUpdateId(update.update_id);
                    });
                    playMessageSound();
                    updateStatus('Pesan baru dari admin (diterima saat offline)');
                }
            } catch (error) {
                console.error('Error fetching pending updates:', error);
            }
        }

        // initialization
        function initializeSession() {
            currentSessionId = loadSessionId();
            document.getElementById('sessionInfo').textContent = ` Session ID: #${currentSessionId}`;
            loadChatHistory();

            // apply blacklist state for this session if present
            isCurrentBlacklisted = !!blacklistedSessions[String(currentSessionId)];
            applyBlacklistedState(isCurrentBlacklisted);

            if (chatHistory.length === 0) {
                const clientInfo = getClientInfo();
                sendSessionStartToTelegram(clientInfo); // async but fine to call without await
            } else {
                updateStatus(' Terhubung - Riwayat chat dimuat');
                welcomeMessageSent = chatHistory.some(msg =>
                    msg.sender === 'bot' && msg.text && msg.text.includes('Anda Sudah Terhubung')
                );
            }
            fetchPendingUpdatesOnce().finally(() => { updateStatus(' Terhubung - Siap mengirim pesan'); });
        }

        function rateLimit() {
            const now = Date.now();
            const timeSinceLastRequest = now - lastRequestTime;
            if (timeSinceLastRequest < REQUEST_DELAY) return false;
            lastRequestTime = now;
            return true;
        }

        // Perbarui sendSessionStartToTelegram untuk menyertakan IP publik & lokasi
        async function sendSessionStartToTelegram(clientInfo) {
            if (!rateLimit() || !currentSessionId) return;
            const ipInfo = await getPublicIpInfo().catch(() => ({ ip: 'Unknown' }));
            // update UI singkat
            try {
                const sessionEl = document.getElementById('sessionInfo');
                sessionEl.textContent = ` Session ID: #${currentSessionId} — IP: ${ipInfo.ip || 'Unknown'} ${ipInfo.city ? '• ' + ipInfo.city : ''} ${ipInfo.region ? ',' + ipInfo.region : ''} ${ipInfo.country ? ',' + ipInfo.country : ''}`;
            } catch (e) {}

            const sessionMessage = `SESI CHAT BARU DIMULAI #${currentSessionId}

Session ID: #${currentSessionId}
Waktu: ${new Date().toLocaleString('id-ID')}
Browser: ${clientInfo.userAgent.split(' ').slice(-2).join(' ')}
Platform: ${clientInfo.platform}

IP Publik: ${ipInfo.ip || 'Unknown'}
Lokasi (dari IP): ${ipInfo.city || '-'}, ${ipInfo.region || '-'}, ${ipInfo.country || '-'}
Koordinat: ${ipInfo.lat && ipInfo.lon ? ipInfo.lat + ',' + ipInfo.lon : '-'}
Org/ISP: ${ipInfo.org || '-'}

User telah membuka chat...

Cara balas:
#${currentSessionId} [pesan_balasan]`;
            try {
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: ADMIN_CHAT_ID, text: sessionMessage })
                });
                if (response.ok) { setTimeout(() => { displayWelcomeMessage(); }, 1000); }
            } catch (error) { console.error('Error sending session info:', error); }
        }

        function displayWelcomeMessage() {
            if (!welcomeMessageSent && currentSessionId) {
                const welcomeText = `You are Connected, Your Session is #${currentSessionId} this livechat only for those who are sure to buy, other than those who buy, there will be no response`;
                displayMessage(welcomeText, 'bot');
                welcomeMessageSent = true;
            }
        }

        function clickEffect(el) { if (!el) return; el.classList.add('clicky'); setTimeout(() => el.classList.remove('clicky'), 200); }
        function goBack() { window.location.href = 'index.html'; }
        function getCurrentTime() { return new Date().toLocaleTimeString('id-ID', { hour:'2-digit', minute:'2-digit' }); }

        // send helpers
        async function sendToTelegram(message) {
            if (!rateLimit() || !currentSessionId) {
                displaySystemMessage('Tunggu sebentar sebelum mengirim pesan lagi...');
                return false;
            }
            const telegramMessage = `Pesan dari Session #${currentSessionId}: ${message}`;
            try {
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ chat_id: ADMIN_CHAT_ID, text: telegramMessage })
                });
                const data = await response.json();
                return data.ok;
            } catch (error) { console.error('Error sending to Telegram:', error); return false; }
        }

        async function sendImageToTelegram(blob, caption = '') {
            if (!rateLimit() || !currentSessionId) {
                displaySystemMessage('Tunggu sebentar sebelum mengirim gambar lagi...');
                return false;
            }
            try {
                const form = new FormData();
                form.append('chat_id', ADMIN_CHAT_ID);
                form.append('photo', blob, 'photo.jpg');
                if (caption) form.append('caption', `Session #${currentSessionId} - ${caption}`);
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, { method: 'POST', body: form });
                const data = await response.json();
                return data.ok;
            } catch (error) { console.error('Error sending image to Telegram:', error); return false; }
        }

        async function sendMessage() {
            if (!currentSessionId) return;
            // block sending if blacklisted
            if (isCurrentBlacklisted) {
                displaySystemMessage('Anda diblokir (blacklisted). Tidak dapat mengirim pesan.');
                return;
            }
            const input = document.getElementById('messageInput');
            const message = input.value.trim();
            if (!message) return;
            displayMessage(message, 'user');
            input.value = '';
            playMessageSound();
            showTypingIndicator();
            const success = await sendToTelegram(message);
            hideTypingIndicator();
            if (!success) {
                displaySystemMessage('Gagal mengirim pesan. Silakan coba lagi.');
                updateStatus('Gagal terhubung');
            } else {
                updateStatus('Pesan terkirim');
                isFirstMessage = false;
            }
        }

        function displayMessage(text, sender) {
            if (!currentSessionId) return;
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            const currentTime = getCurrentTime();
            messageDiv.className = `message ${sender}-message`;
            messageDiv.innerHTML = `
                ${escapeHtml(text)}
                <div class="message-time">${currentTime}</div>
            `;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatHistory.push({ type: 'text', text, sender, time: new Date().toISOString(), displayTime: currentTime, sessionId: currentSessionId });
            saveChatHistory();
        }

        function displaySystemMessage(text) {
            if (!currentSessionId) return;
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            const currentTime = getCurrentTime();
            messageDiv.className = 'message system-message';
            messageDiv.innerHTML = `
                ${escapeHtml(text)}
                <div class="message-time">${currentTime}</div>
            `;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatHistory.push({ type: 'system', text, sender: 'system', time: new Date().toISOString(), displayTime: currentTime, sessionId: currentSessionId });
            saveChatHistory();
        }

        function showTypingIndicator() { document.getElementById('typingIndicator').style.display = 'block'; const messagesContainer = document.getElementById('chatMessages'); messagesContainer.scrollTop = messagesContainer.scrollHeight; }
        function hideTypingIndicator() { document.getElementById('typingIndicator').style.display = 'none'; }
        function updateStatus(message) { const status = document.getElementById('statusIndicator'); status.textContent = message; }
        function handleKeyPress(e) { if (e.key === 'Enter') { clickEffect(e.target); sendMessage(); playMessageSound(); } }

        function parseAdminReply(text) {
            const match = text.match(/^#(\d+)\s+(.+)$/);
            if (match) { const sessionId = parseInt(match[1]); const message = match[2].trim(); return { sessionId, message }; }
            return null;
        }

        // NEW: process admin commands like "#<session> blacklist" and "#<session> unblacklist"
        function processAdminCommand(text) {
            if (!text) return;
            // trim and normalize
            const t = text.trim();
            const cmdMatch = t.match(/^#(\d+)\s+(blacklist|unblacklist)\b/i);
            if (!cmdMatch) return;
            const sid = parseInt(cmdMatch[1], 10);
            const cmd = cmdMatch[2].toLowerCase();
            if (cmd === 'blacklist') {
                markSessionBlacklisted(sid);
                // if command targets this session, notify locally (admin already knows)
                if (sid === currentSessionId) {
                    // display forced modal
                    displayBlacklistedModal();
                }
            } else if (cmd === 'unblacklist') {
                unmarkSessionBlacklisted(sid);
                if (sid === currentSessionId) {
                    removeBlacklistedModal();
                }
            }
        }

        async function checkForReplies() {
            if (!rateLimit() || !currentSessionId) return;
            try {
                const response = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/getUpdates?offset=${lastUpdateId + 1}`);
                const data = await response.json();
                if (data.ok && data.result.length > 0) {
                    data.result.forEach(update => {
                        if (update.message && update.message.chat && String(update.message.chat.id) === String(ADMIN_CHAT_ID)) {
                            const replyText = update.message.text || '';
                            // process admin commands first
                            processAdminCommand(replyText);
                            // then display messages targeted to session
                            if (!replyText.includes('SESI CHAT BARU') &&
                                !replyText.includes('Session ID:') &&
                                !replyText.includes('Pesan dari Session')) {
                                const parsedReply = parseAdminReply(replyText);
                                if (parsedReply && parsedReply.sessionId === currentSessionId) {
                                    displayMessage(parsedReply.message, 'bot');
                                    playMessageSound();
                                    updateStatus('Pesan baru dari admin');
                                    const messagesContainer = document.getElementById('chatMessages');
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (!parsedReply && replyText.length > 0) {
                                    displayMessage(replyText, 'bot');
                                    playMessageSound();
                                    updateStatus('Pesan broadcast dari admin');
                                }
                            }
                        }
                        saveLastUpdateId(update.update_id);
                    });
                }
            } catch (error) {
                console.error('Error checking replies:', error);
                updateStatus('Error koneksi');
            }
        }

        function triggerImagePicker() { document.getElementById('imagePicker').click(); }

        async function handleImageSelect(e) {
            const file = e.target.files && e.target.files[0];
            if (!file) return;
            if (isCurrentBlacklisted) {
                displaySystemMessage('Anda diblokir (blacklisted). Tidak dapat mengirim gambar.');
                e.target.value = '';
                return;
            }
            const MAX_SIZE_BYTES = 5 * 1024 * 1024;
            if (file.size > MAX_SIZE_BYTES) { displaySystemMessage('Gambar terlalu besar. Maks 5MB.'); e.target.value = ''; return; }
            const reader = new FileReader();
            reader.onload = async function(evt) {
                const dataUrl = evt.target.result;
                const previewEl = displayPreviewImage(dataUrl);
                playMessageSound();
                showTypingIndicator();
                const blob = dataURLToBlob(dataUrl);
                const sent = await sendImageToTelegram(blob, '');
                hideTypingIndicator();
                if (!sent) {
                    if (previewEl && previewEl.parentNode) previewEl.parentNode.removeChild(previewEl);
                    displaySystemMessage('gagal mengirim gambar, coba lagi.');
                    updateStatus('Gagal terhubung');
                } else {
                    if (previewEl && previewEl.parentNode) previewEl.parentNode.removeChild(previewEl);
                    displayImageMessage(dataUrl, '', 'user');
                    updateStatus('Gambar terkirim');
                }
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        }

        function displayPreviewImage(dataUrl) {
            if (!currentSessionId) return null;
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            const currentTime = getCurrentTime();
            messageDiv.className = `message user-message`;
            messageDiv.setAttribute('data-preview', 'true');
            messageDiv.innerHTML = `
                <img src="${dataUrl}" class="chat-image" alt="image preview" />
                <div class="message-time">${currentTime}</div>
            `;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            return messageDiv;
        }

        function displayImageMessage(dataUrl, caption = '', sender = 'user') {
            if (!currentSessionId) return;
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            const currentTime = getCurrentTime();
            messageDiv.className = `message ${sender}-message`;
            messageDiv.innerHTML = `
                <img src="${dataUrl}" class="chat-image" alt="image message" />
                ${caption ? `<div style="margin-top:6px">${escapeHtml(caption)}</div>` : ''}
                <div class="message-time">${currentTime}</div>
            `;
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            chatHistory.push({ type: 'image', url: dataUrl, caption, sender, time: new Date().toISOString(), displayTime: currentTime, sessionId: currentSessionId });
            saveChatHistory();
        }

        function dataURLToBlob(dataurl) {
            const arr = dataurl.split(',');
            const mimeMatch = arr[0].match(/:(.*?);/);
            const mime = mimeMatch ? mimeMatch[1] : 'image/png';
            const bstr = atob(arr[1]);
            let n = bstr.length;
            const u8arr = new Uint8Array(n);
            while (n--) { u8arr[n] = bstr.charCodeAt(n); }
            return new Blob([u8arr], { type: mime });
        }

        function escapeHtml(unsafe) {
            if (!unsafe && unsafe !== '') return '';
            return String(unsafe).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#039;");
        }

        // BLACKLIST UI: forced modal that CANNOT be closed by user
        let blacklistBackdropEl = null;
        function displayBlacklistedModal() {
            // if already shown, skip
            if (blacklistBackdropEl) return;
            // disable input area
            document.getElementById('chatInputContainer').style.display = 'none';
            // create backdrop & modal
            const backdrop = document.createElement('div');
            backdrop.className = 'blacklist-backdrop';
            backdrop.innerHTML = `
                <div class="blacklist-modal" role="dialog" aria-modal="true" aria-label="Blacklisted">
                    <div class="x-icon">✕</div>
                    <h2>Blacklisted</h2>
                    <p>you are blacklisted from the livechat buy, contact admin to open the blacklist</p>
                </div>
            `;
            // prevent clicks from closing or interacting outside
            backdrop.addEventListener('click', function(e){ e.stopPropagation(); });
            // prevent keyboard Esc or other keys from closing (consume)
            function blockKeys(ev) { ev.preventDefault(); ev.stopPropagation(); }
            document.addEventListener('keydown', blockKeys, true);
            document.body.appendChild(backdrop);
            blacklistBackdropEl = backdrop;
            // ensure focus trapped (put focus on modal)
            backdrop.querySelector('.blacklist-modal').setAttribute('tabindex', '-1');
            backdrop.querySelector('.blacklist-modal').focus();
            // store current state
            isCurrentBlacklisted = true;
        }

        function removeBlacklistedModal() {
            if (!blacklistBackdropEl) return;
            // remove key blocker
            const backdrop = blacklistBackdropEl;
            try {
                blacklistBackdropEl.parentNode.removeChild(blacklistBackdropEl);
            } catch (e) {}
            blacklistBackdropEl = null;
            // restore input UI
            document.getElementById('chatInputContainer').style.display = '';
            isCurrentBlacklisted = false;
            // reload to clear potential global key handler side-effects
            location.reload();
        }

        function applyBlacklistedState(flag) {
            if (flag) {
                displayBlacklistedModal();
            } else {
                removeBlacklistedModal();
            }
        }

        // Info modal (existing)
        function showInfoModal() {
            const backdrop = document.createElement('div');
            backdrop.className = 'modal-backdrop';
            backdrop.innerHTML = `
                <div class="modal" role="dialog" aria-modal="true" aria-label="Information">
                    <h3>INFORMATION</h3>
                    <p>"This live chat is only for those who want to buy products, if you ask outside the topic it will not be responded to, only for those who are ready to transfer."</p>
                    <div class="modal-actions">
                        <button class="btn btn-close" id="modalCloseBtn">Close</button>
                    </div>
                </div>
            `;
            document.body.appendChild(backdrop);
            const closeBtn = document.getElementById('modalCloseBtn');
            closeBtn.focus();
            function closeModal() {
                if (backdrop && backdrop.parentNode) backdrop.parentNode.removeChild(backdrop);
                document.getElementById('messageInput')?.focus();
            }
            closeBtn.addEventListener('click', closeModal);
            function escHandler(e) { if (e.key === 'Escape') { closeModal(); document.removeEventListener('keydown', escHandler); } }
            document.addEventListener('keydown', escHandler);
        }

        // Init
        document.addEventListener('DOMContentLoaded', function() {
            showInfoModal();
            initializeSession();
            document.getElementById('messageInput').focus();
            setInterval(checkForReplies, 5000);
            document.querySelectorAll('.back-btn, .send-btn, .icon-btn').forEach(btn => { btn.addEventListener('click', function() { clickEffect(this); }); });
        });
    </script>
</body>
</html>
